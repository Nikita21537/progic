import os
import time
import argparse
from array import array
from tqdm import tqdm
from fast_sha256 import SHA256, generate_key, PRNG, xor_bytes, substitution, permutation

# --- Constants ---
S1 = bytes([
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
])
S2 = bytes([255 - i for i in range(256)])
P1_order = array('i', list(reversed(range(16))))
P2_order = array('i', [4, 5, 6, 7, 0, 1, 2, 3, 12, 13, 14, 15, 8, 9, 10, 11])
P2_inv = array('i', [P2_order.tolist().index(i) for i in range(16)])


# --- Batched Processing ---
def process_chunk(chunk, prng, block_size=16, encrypt=True):
    buffer = bytearray(chunk)
    result = bytearray()
    blocks = [bytes(buffer[i:i + block_size]) for i in range(0, len(buffer), block_size)]
    if not blocks:
        return bytes(result), buffer
    total_rand = len(blocks) * block_size
    rand_data = prng.rand_bytes(total_rand)
    if encrypt:
        for i, block in enumerate(blocks):
            start = i * block_size
            sub1 = substitution(block, S1)
            perm1 = permutation(sub1, memoryview(P1_order))
            sub2 = substitution(perm1, S2)
            perm2 = permutation(sub2, P2_order)
            result.extend(xor_bytes(perm2, rand_data[start:start + block_size]))
    else:
        for i, block in enumerate(blocks):
            start = i * block_size
            xor = xor_bytes(block, rand_data[start:start + block_size])
            perm2 = permutation(xor, P2_inv)
            sub2 = substitution(perm2, S2)
            perm1 = permutation(sub2, P1_order)
            result.extend(substitution(perm1, S1))
    remaining = buffer[len(blocks) * block_size:]
    return bytes(result), remaining


def encrypt_block(block, prng):
    sub1 = substitution(block, S1)
    perm1 = permutation(sub1, P1_order)
    sub2 = substitution(perm1, S2)
    perm2 = permutation(sub2, P2_order)
    return xor_bytes(perm2, prng.rand_bytes(16))


# --- File Encryption ---
def encrypt_file(input_path, output_path, password, salt, verbose=False):
    start_time = time.time()
    key = generate_key(password.encode(), salt.encode())
    prng = PRNG(int.from_bytes(key[:4], 'big'))
    block_size = 16
    file_size = os.path.getsize(input_path)
    pad_len = block_size - (file_size % block_size or block_size)
    padded_size = file_size + pad_len

    with open(input_path, 'rb') as f_in, open(output_path, 'wb') as f_out:
        with tqdm(total=padded_size, unit='B', unit_scale=True, desc='–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ', disable=not verbose) as pbar:
            buffer = bytearray()
            while True:
                chunk = f_in.read(1024 * 1024 * 8)
                if not chunk:
                    break
                buffer.extend(chunk)
                processed, buffer = process_chunk(buffer, prng, block_size, encrypt=True)
                f_out.write(processed)
                pbar.update(len(processed))

            if buffer:
                pad = bytes([pad_len] * pad_len)
                processed = encrypt_block(bytes(buffer) + pad, prng)
                f_out.write(processed)
                pbar.update(len(buffer) + pad_len)

            hash_data = SHA256()
            hash_data.update(bytes(buffer) + pad if buffer else b'')
            hash_mask = prng.rand_bytes(32)
            f_out.write(xor_bytes(hash_data.digest(), hash_mask))
            pbar.update(32)

    elapsed = time.time() - start_time
    speed = padded_size / (1024 * 1024) / elapsed

    if verbose:
        print(f"üîí –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ñ–∞–π–ª —Å–æ—Ö—Ä–∞–Ω—ë–Ω –∫–∞–∫: {output_path}")
        print(f"‚è± –í—Ä–µ–º—è: {elapsed:.2f} —Å | üöÄ –°–∫–æ—Ä–æ—Å—Ç—å: {speed:.2f} –ú–ë/—Å")


# --- File Decryption ---
def decrypt_file(input_path, password, salt, output_path=None, verbose=False):
    start_time = time.time()
    key = generate_key(password.encode(), salt.encode())
    prng = PRNG(int.from_bytes(key[:4], 'big'))

    with open(input_path, 'rb') as f_in:
        f_in.seek(0, os.SEEK_END)
        file_size = f_in.tell()
        if file_size < 32:
            raise ValueError("–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞")
        f_in.seek(0)

        encrypted_data_size = file_size - 32
        decrypted = bytearray()

        with tqdm(total=encrypted_data_size, unit='B', unit_scale=True, desc='–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ',
                  disable=not verbose) as pbar:
            buffer = bytearray()
            while encrypted_data_size > 0:
                chunk = f_in.read(1024 * 1024 * 8)
                encrypted_data_size -= len(chunk)
                buffer.extend(chunk)
                processed, buffer = process_chunk(buffer, prng, 16, encrypt=False)
                decrypted.extend(processed)
                pbar.update(len(processed))

            stored_hash = xor_bytes(f_in.read(32), prng.rand_bytes(32))
            computed_hash = SHA256()
            computed_hash.update(bytes(decrypted))  # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º bytearray –≤ bytes

            if stored_hash != computed_hash.digest():
                raise ValueError("–•—ç—à –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç")

        # Remove padding
        pad_len = decrypted[-1]
        decrypted = decrypted[:-pad_len]

        # Generate output path
        if output_path is None:
            if input_path.endswith('.enc'):
                output_path = input_path[:-4]
            else:
                output_path = input_path + '.dec'

        with open(output_path, 'wb') as f_out:
            f_out.write(decrypted)

    elapsed = time.time() - start_time
    speed = (file_size - 32) / (1024 * 1024) / elapsed

    if verbose:
        print(f"üîì –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ñ–∞–π–ª —Å–æ—Ö—Ä–∞–Ω—ë–Ω –∫–∞–∫: {output_path}")
        print(f"‚è± –í—Ä–µ–º—è: {elapsed:.2f} —Å | üöÄ –°–∫–æ—Ä–æ—Å—Ç—å: {speed:.2f} –ú–ë/—Å")

    return output_path


# --- CLI Entry Point ---
def main():
    parser = argparse.ArgumentParser(description="–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–æ–≤")
    parser.add_argument('--encrypt', action='store_true')
    parser.add_argument('--decrypt', action='store_true')
    parser.add_argument('--input', type=str, required=True)
    parser.add_argument('--output', type=str)
    parser.add_argument('--password', type=str, required=True)
    parser.add_argument('--salt', type=str, default='s@1t')
    parser.add_argument('--verbose', action='store_true')
    args = parser.parse_args()

    if args.encrypt:
        output_path = args.output or args.input + '.enc'
        encrypt_file(args.input, output_path, args.password, args.salt, args.verbose)

    elif args.decrypt:
        decrypt_file(args.input, args.password, args.salt, args.output, args.verbose)

    else:
        parser.print_help()


if __name__ == "__main__":
    main()
